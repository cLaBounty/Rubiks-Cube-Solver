# Rubik's Cube Solver

### [Demo](https://www.youtube.com/watch?v=oZSwaQ6uV1U) | [Download](https://clabounty.itch.io/rubiks-cube-solver)

## Summary
A 3D Rubik's Cube simulation and solver for 2x2, 3x3, and 4x4 cubes. Implemented a popular blindfolded solving method used by competitive speed cubers. Added functionality to solve and manually turn the cube by clicking a face and dragging the mouse in the direction of the turn. Built in Java using a graphical library and IDE called Processing.

## How it was Built
This project was built in Processing, which is a graphical library and IDE for Java that is typically used for visual design and electronic arts. Processing provided a graphical user interface (GUI) as well as many built-in classes, functions, and variables that were used to help develop this project. Before I could implement a method to solve a Rubik's Cube, I first had to build the Rubik's Cube simulation. I knew that I wanted the simulation to be in three dimensions and Processing allows for drawing in 3D when you use the built-in P3D render mode. Using the P3D renderer allowed for the Rubik's Cube to be drawn in 3D, but there was still no way to see anything other than the front of it. I needed a camera to move around in the 3D space and the PeasyCam library allowed me to simply add a mouse-driven camera to this project. For building the Rubik's Cube itself, I decided to break it down into 3 separate classes: Cube, Cell, and Face. A Rubik's Cube is an instance of the Cube class and a Cube has an array of many small boxes that I called Cells. Every Cell has a Face on each of its 6 sides and the color of that Face depends on its direction and where the Cell is located on the Cube. For example, a Cell on the top layer of the Cube will always have a white colored Face and a Cell on the left side of the Cube will always have an orange colored Face. A Face can also sometimes be inside the Cube and these are always colored black because they will become visible when the Cube is turning. To turn the Cube, you can think of the slice that is being turned as a 2D matrix since all of the Cells being rotated share an X, Y, or Z position on the Cube. Processing has a built-in class and function for rotating 2D matrices, which made it simple to rotate any slice on the Cube 90 degrees in either direction. When implementing the solve method, I knew that it was going to be extremely important to not only make a specific turn, but also to make a specific sequence of turns. To make a specific turn, I decided to make a Turn Animation class that takes in a character and an integer that represent [Rubik's Cube notation](https://jperm.net/3x3/moves). To make a sequence of turns, I simply iterated through an ArrayList of Turn Animations. I decided to use an ArrayList rather than the built-in array in Java because it allowed me to modify the size and add turns to the sequence whenever I needed to.

## The Solving Method
The blindfolded method that I chose to implement starts by solving all of the center pieces, then all of the edges, and finally the corners. "U2" is the name of the method used to solve the centers, "M2" is the method to solve the edges, and "Old Pochmann" is the method to solve the corners. Each method is explained extremely well in [this](https://www.youtube.com/watch?v=dG4J_ro_dDQ) video, but the general idea behind each of them is the same. Each method solves one piece at a time using an algorithm that only swaps two pieces. These pieces are called the buffer and the target. You start by looking at the buffer and find where it needs to be moved to in order to be solved. The piece that is currently in that position can be moved to the target using a specific sequence of turns called the setup moves. The pieces can then be swapped using the swapping algorithm, however, it is not solved just yet. It is currently still in the target position, not its solved position where it needs to be. It must be moved back to its solved position by reversing the setup moves that were used to get it there in the first place. The piece is now solved and there is a new unsolved piece in the buffer position. The same process can be repeated for that piece and every piece after it until all of the centers, edges, or corners are solved.

## What I Learned
- Built-in Processing Classes, Functions, and Variables
- 2D and 3D Matrix Transformations
- 3D Unit Vector Directions
- Java Syntax and Keywords
- OOP Concepts in Java
